# To run the server (from the directory containing the app.py file): 
#   poetry run uvicorn app:app --reload

# uvicorn - ASGI web server (https://www.uvicorn.org/).
# --reload - automatically reload app after each change.
import time
from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse

app = FastAPI()

# Returns a "JSONResponse" object.
@app.get("/info")
async def info(timestamp: int = None):
    return { "msg": f"My first FastAPI application: {timestamp}" }

@app.get("/v2/info")
async def info_v2():
    return { "msg": "Version 2 of my first application" }

def add_timestamp_param_to_request(request: Request, timestamp: int):
    timestamp_param = b"timestamp=" + str(timestamp).encode()
    if  query_string := request.scope["query_string"]:
        request.scope["query_string"] = query_string + b"&" + timestamp_param
    else:
        request.scope["query_string"] = timestamp_param

# Function-based middleware definition.
# `request` = all information associated with the incoming request.
# `call_next` = function that returns a response generated by the endpoint.
# It has an access to the incoming request (by the `request` param) and to
# the outgoing response (returned by the `call_next` function).
@app.middleware("http")
async def set_timestamp_on_request_and_response(request: Request, call_next):
    given_timestamp = request.query_params.get("timestamp")

    # Add timestamp to the request.
    if not given_timestamp:
        given_timestamp = int(time.time())
        add_timestamp_param_to_request(request, given_timestamp)

    # Process the modified request and intercept the response
    response = await call_next(request)

    # Add custom header to the response
    if isinstance(response, StreamingResponse):
        response.headers["X-Timestamp"] = str(given_timestamp)

    return response