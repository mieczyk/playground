import logging
import time
from datetime import datetime, timedelta
from http import HTTPStatus

from fastapi import Request
from fastapi.responses import JSONResponse, StreamingResponse
from starlette.middleware.base import BaseHTTPMiddleware

logger = logging.getLogger(__name__)


# Class-based middleware responsible for rate limiting.
# It checks how many requests have been made from a sepific IP within a specific period
# and rejects further requests if the limit is exceeded.
class RateLimitMiddleware(BaseHTTPMiddleware):
    # Allow max 10 requests per second.
    RATE_LIMIT_DURATION = timedelta(seconds=1)
    RATE_LIMIT_REQUESTS = 10

    # Provide middleware configration here.
    def __init__(self, app):
        super().__init__(app)
        self.request_counts = {}  # Stores requests count for each IP.

    # Middleware logic goes here.
    async def dispatch(self, request, call_next):
        logger.info("RateLimitMiddleware: REQUEST")
        client_ip = request.client.host

        request_count, last_request = self.request_counts.get(
            client_ip, (0, datetime.min)
        )

        elapsed_time = datetime.now() - last_request

        if elapsed_time > self.RATE_LIMIT_DURATION:
            request_count = 1
        else:
            if request_count >= self.RATE_LIMIT_REQUESTS:
                return JSONResponse(
                    status_code=HTTPStatus.TOO_MANY_REQUESTS,  # 429
                    content={"message": "Rate limit exceeded. Please try again later."},
                )
            request_count += 1

        self.request_counts[client_ip] = (request_count, datetime.now())

        response = await call_next(request)

        logger.info("RateLimitMiddleware: RESPONSE")

        return response


# Function-based middleware definition.
# `request` = all information associated with the incoming request.
# `call_next` = function that returns a response generated by the endpoint.
# It has an access to the incoming request (by the `request` param) and to
# the outgoing response (returned by the `call_next` function).
async def set_timestamp_on_request_and_response(request: Request, call_next):
    logger.info("set_timestamp_on_request_and_response: REQUEST")
    given_timestamp = request.query_params.get("timestamp")

    # Add timestamp to the request.
    if not given_timestamp:
        given_timestamp = int(time.time())
        __add_timestamp_param_to_request(request, given_timestamp)

    # Process the modified request and intercept the response.
    # It actually delegates the processing to the next middleware in the chain.
    response = await call_next(request)

    logger.info("set_timestamp_on_request_and_response: RESPONSE")

    # Add custom header to the response
    if isinstance(response, StreamingResponse):
        response.headers["X-Timestamp"] = str(given_timestamp)

    return response


def __add_timestamp_param_to_request(request: Request, timestamp: int):
    timestamp_param = b"timestamp=" + str(timestamp).encode()
    if query_string := request.scope["query_string"]:
        request.scope["query_string"] = query_string + b"&" + timestamp_param
    else:
        request.scope["query_string"] = timestamp_param


async def another_middleware_function(request: Request, call_next):
    logger.info("another_middleware_function: REQUEST")
    response = await call_next(request)
    logger.info("another_middleware_function: RESPONSE")
    return response
