# To run the server (from the directory containing the app.py file): 
#   poetry run uvicorn app:app --reload

# uvicorn - ASGI web server (https://www.uvicorn.org/).
# --reload - automatically reload app after each change.
import time
from datetime import datetime, timedelta
from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse, JSONResponse
from http import HTTPStatus
from starlette.middleware.base import BaseHTTPMiddleware

app = FastAPI()

# Returns a "JSONResponse" object.
@app.get("/info")
async def info(timestamp: int = None):
    return { "msg": f"My first FastAPI application: {timestamp}" }

@app.get("/v2/info")
async def info_v2():
    return { "msg": "Version 2 of my first application" }

def add_timestamp_param_to_request(request: Request, timestamp: int):
    timestamp_param = b"timestamp=" + str(timestamp).encode()
    if query_string := request.scope["query_string"]:
        request.scope["query_string"] = query_string + b"&" + timestamp_param
    else:
        request.scope["query_string"] = timestamp_param

# Function-based middleware definition.
# `request` = all information associated with the incoming request.
# `call_next` = function that returns a response generated by the endpoint.
# It has an access to the incoming request (by the `request` param) and to
# the outgoing response (returned by the `call_next` function).
@app.middleware("http")
async def set_timestamp_on_request_and_response(request: Request, call_next):
    given_timestamp = request.query_params.get("timestamp")

    # Add timestamp to the request.
    if not given_timestamp:
        given_timestamp = int(time.time())
        add_timestamp_param_to_request(request, given_timestamp)

    # Process the modified request and intercept the response
    response = await call_next(request)

    # Add custom header to the response
    if isinstance(response, StreamingResponse):
        response.headers["X-Timestamp"] = str(given_timestamp)

    return response

# Class-based middleware responsible for rate limiting.
# It checks how many requests have been made from a sepific IP within a specific period
# and rejects further requests if the limit is exceeded.
class RateLimitMiddleware(BaseHTTPMiddleware):
    # Allow max 3 requests per second.
    RATE_LIMIT_DURATION = timedelta(seconds=1)
    RATE_LIMIT_REQUESTS = 3

    # Provide middleware configration here.
    def __init__(self, app):
        super().__init__(app)
        self.request_counts = {}    # Stores requests count for each IP.

    # Middleware logic goes here.
    async def dispatch(self, request, call_next):
        
        client_ip = request.client.host

        request_count, last_request = self.request_counts.get(client_ip, (0, datetime.min))

        elapsed_time = datetime.now() - last_request

        if elapsed_time > self.RATE_LIMIT_DURATION:
            request_count = 1
        else:
            if request_count >= self.RATE_LIMIT_REQUESTS:
                return JSONResponse(
                    status_code=HTTPStatus.TOO_MANY_REQUESTS,   # 429
                    content={"message": "Rate limit exceeded. Please try again later."}
                )
            request_count += 1


        self.request_counts[client_ip] = (request_count, datetime.now())

        response = await call_next(request)

        return response

# Register custom class-based middleware. 
# Will be executed afer `set_timestamp_on_request_and_response`.
app.add_middleware(RateLimitMiddleware)